pub mod builder;
pub mod registry;
pub mod types;
pub use types::UnsafeCss;

use silex_core::reactivity::{Effect, on_cleanup};
use silex_core::traits::{Get, IntoSignal, With};
use silex_dom::attribute::{ApplyTarget, ApplyToDom, IntoStorable};
use silex_dom::document;
use std::cell::RefCell;
use std::collections::{
    HashMap,
    hash_map::{DefaultHasher, Entry},
};
use std::fmt::Display;
use std::hash::{Hash, Hasher};
use std::rc::Rc;
use wasm_bindgen::JsCast;
use web_sys::{Element, HtmlElement, Node, SvgElement};

/// Injects a CSS string into the document head with a unique ID.
/// This function is idempotent: if a style with the given ID already exists, it does nothing.
///
/// # Arguments
///
/// * `id` - A unique identifier for the style block (e.g. "style-slx-123456").
/// * `content` - The CSS content to inject.
pub fn inject_style(id: &str, content: &str) {
    let doc = document();

    // Check if style already exists to avoid duplication
    if doc.get_element_by_id(id).is_some() {
        return;
    }

    let head = doc.head().expect("No <head> element found in document");

    // Create <style> element
    let style_el = doc
        .create_element("style")
        .expect("Failed to create style element");

    // Set ID and content
    style_el.set_id(id);
    style_el.set_inner_html(content);

    // Append to head
    let style_node: Node = style_el.unchecked_into();
    head.append_child(&style_node)
        .expect("Failed to append style to head");
}

pub type CssVariableGetter = Rc<dyn Fn() -> String>;

/// Manages an injected <style> block uniquely for a component instance.
/// It cleans up the tag when dropped, preventing CSSOM leaks.
struct DynamicStyleState {
    ref_count: usize,
    style_el: Element,
}

thread_local! {
    static DYNAMIC_STYLE_REGISTRY: RefCell<HashMap<String, Rc<RefCell<DynamicStyleState>>>> = RefCell::new(HashMap::new());
}

/// Manages an injected <style> block uniquely for a component instance.
/// It cleans up the tag when dropped, preventing CSSOM leaks.
pub struct DynamicStyleManager {
    id: Option<String>,
}

impl Default for DynamicStyleManager {
    fn default() -> Self {
        Self::new()
    }
}

impl DynamicStyleManager {
    pub fn new() -> Self {
        Self { id: None }
    }

    pub fn new_with_id(id: &str) -> Self {
        let mut mgr = Self::new();
        mgr.update(id, "");
        mgr
    }

    pub fn update(&mut self, id: &str, content: &str) {
        if self.id.as_deref() == Some(id) {
            return;
        }

        DYNAMIC_STYLE_REGISTRY.with(|registry| {
            let mut reg = registry.borrow_mut();
            let state_rc = reg.entry(id.to_string()).or_insert_with(|| {
                let doc = document();
                let head = doc.head().expect("No <head> element found in document");

                let style_el = doc
                    .create_element("style")
                    .expect("Failed to create style element");

                style_el.set_id(id);
                if !content.is_empty() {
                    style_el.set_inner_html(content);
                }

                let style_node: Node = style_el.clone().into();
                head.append_child(&style_node)
                    .expect("Failed to append style to head");

                Rc::new(RefCell::new(DynamicStyleState {
                    ref_count: 0,
                    style_el,
                }))
            });

            state_rc.borrow_mut().ref_count += 1;
        });

        if let Some(old_id) = self.id.take() {
            Self::release(&old_id);
        }
        self.id = Some(id.to_string());
    }

    fn release(id: &str) {
        DYNAMIC_STYLE_REGISTRY.with(|registry| {
            let mut reg = registry.borrow_mut();
            if let Entry::Occupied(entry) = reg.entry(id.to_string()) {
                let count = {
                    let mut state = entry.get().borrow_mut();
                    state.ref_count -= 1;
                    state.ref_count
                };
                if count == 0 {
                    let state = entry.remove();
                    state.borrow().style_el.remove();
                }
            }
        });
    }
}

impl Drop for DynamicStyleManager {
    fn drop(&mut self) {
        if let Some(id) = &self.id {
            Self::release(id);
        }
    }
}

/// A structure representing a dynamic CSS class with reactive variables and dynamic rules.
/// Generated by the `css!` macro when dynamic interpolation `$(...)` is used.
#[derive(Clone)]
pub struct DynamicCss {
    /// The generated class name (e.g., "slx-1234abcd")
    pub class_name: &'static str,
    /// A list of (css_variable_name, value_getter) pairs.
    /// These are applied as inline styles to the element.
    pub vars: Vec<(&'static str, CssVariableGetter)>,
    /// A list of (css_template, list of value getters) pairs for dynamic selector blocks.
    pub rules: Vec<(&'static str, Vec<CssVariableGetter>)>,
}

impl ApplyToDom for DynamicCss {
    fn apply(self, el: &Element, target: ApplyTarget) {
        // 1. Apply class name (as normal string class)
        // This ensures the element gets the static CSS rules.
        self.class_name.apply(el, target);

        // 2. Apply dynamic variables (always as inline styles)
        for (name, getter) in self.vars {
            let el = el.clone();
            let name = name.to_string(); // 'static -> String for closure capture

            // Create an effect to keep the CSS variable in sync with the signal/expression
            Effect::new(move |_| {
                let value = getter();
                // Attempt to get style declaration from HtmlElement or SvgElement
                if let Some(style) = el
                    .dyn_ref::<HtmlElement>()
                    .map(|e| e.style())
                    .or_else(|| el.dyn_ref::<SvgElement>().map(|e| e.style()))
                {
                    // Set the CSS variable (e.g., --slx-1234-0: red)
                    let _ = style.set_property(&name, &value);
                }
            });
        }

        // 3. Apply isolated component dynamic rules
        if !self.rules.is_empty() {
            let manager = Rc::new(RefCell::new(Some(DynamicStyleManager::new())));
            let manager_cleanup = manager.clone();
            on_cleanup(move || {
                if let Ok(mut opt_mgr) = manager_cleanup.try_borrow_mut() {
                    let _ = opt_mgr.take();
                }
            });

            let rules = self.rules;
            let el_clone = el.clone();
            let base_class = self.class_name;

            Effect::new(move |prev_class: Option<String>| {
                let mut hasher = DefaultHasher::new();
                Hash::hash(b"silex-dyn-salt-css-v1", &mut hasher);

                let mut resolved_rules = Vec::new();

                for (template, getters) in &rules {
                    let mut result_rule = template.to_string();
                    for getter in getters {
                        let val = getter();
                        if let Some(pos) = result_rule.find("{}") {
                            result_rule.replace_range(pos..pos + 2, &val);
                        }
                    }
                    Hash::hash(&result_rule, &mut hasher);
                    resolved_rules.push(result_rule);
                }

                let hash_val = hasher.finish();
                let dyn_class = format!("{}-dyn-{:x}", base_class, hash_val);

                if Some(&dyn_class) != prev_class.as_ref() {
                    if let Some(old_class) = &prev_class {
                        let _ = el_clone.class_list().remove_1(old_class);
                    }
                    let _ = el_clone.class_list().add_1(&dyn_class);

                    let mut combined_css = String::new();
                    for rule in resolved_rules {
                        let rule_with_dyn_class = rule.replace(base_class, &dyn_class);
                        combined_css.push_str(&rule_with_dyn_class);
                        combined_css.push('\n');
                    }

                    if let Ok(mut opt) = manager.try_borrow_mut()
                        && let Some(mgr) = opt.as_mut()
                    {
                        mgr.update(&dyn_class, &combined_css);
                    }
                }

                dyn_class
            });
        }
    }
}

// Allow passing DynamicCss directly to .class() or .attr()
impl IntoStorable for DynamicCss {
    type Stored = Self;
    fn into_storable(self) -> Self::Stored {
        self
    }
}

/// Helper function to create a reactive string getter from any signal-like value.
/// Used by the css! macro to handle $(...) interpolation.
pub fn make_dynamic_val_for<P, S>(source: S) -> Rc<dyn Fn() -> String>
where
    S: IntoSignal,
    S::Value: Clone + Sized + types::ValidFor<P> + Display,
    S::Signal: Get + 'static,
    <S::Signal as With>::Value: Display,
{
    let signal = source.into_signal();
    Rc::new(move || format!("{}", signal.get()))
}
