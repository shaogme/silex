pub mod types;
pub use types::UnsafeCss;

use silex_core::traits::{Get, IntoSignal, With};
use silex_dom::attribute::{ApplyTarget, ApplyToDom, IntoStorable};
use silex_dom::document;
use std::fmt::Display;
use std::rc::Rc;
use wasm_bindgen::JsCast;

/// Injects a CSS string into the document head with a unique ID.
/// This function is idempotent: if a style with the given ID already exists, it does nothing.
///
/// # Arguments
///
/// * `id` - A unique identifier for the style block (e.g. "style-slx-123456").
/// * `content` - The CSS content to inject.
pub fn inject_style(id: &str, content: &str) {
    let doc = document();

    // Check if style already exists to avoid duplication
    if doc.get_element_by_id(id).is_some() {
        return;
    }

    let head = doc.head().expect("No <head> element found in document");

    // Create <style> element
    let style_el = doc
        .create_element("style")
        .expect("Failed to create style element");

    // Set ID and content
    style_el.set_id(id);
    style_el.set_inner_html(content);

    // Append to head
    let style_node: web_sys::Node = style_el.unchecked_into();
    head.append_child(&style_node)
        .expect("Failed to append style to head");
}

pub type CssVariableGetter = Rc<dyn Fn() -> String>;

/// Manages an injected <style> block uniquely for a component instance.
/// It cleans up the tag when dropped, preventing CSSOM leaks.
pub struct DynamicStyleManager {
    style_el: web_sys::Element,
}

impl DynamicStyleManager {
    pub fn new(id: &str) -> Self {
        let doc = document();
        let head = doc.head().expect("No <head> element found in document");

        let style_el = doc
            .create_element("style")
            .expect("Failed to create style element");

        style_el.set_id(id);

        let style_node: web_sys::Node = style_el.clone().into();
        head.append_child(&style_node)
            .expect("Failed to append style to head");

        Self { style_el }
    }

    pub fn update(&self, content: &str) {
        self.style_el.set_inner_html(content);
    }
}

impl Drop for DynamicStyleManager {
    fn drop(&mut self) {
        self.style_el.remove();
    }
}

/// A structure representing a dynamic CSS class with reactive variables and dynamic rules.
/// Generated by the `css!` macro when dynamic interpolation `$(...)` is used.
#[derive(Clone)]
pub struct DynamicCss {
    /// The generated class name (e.g., "slx-1234abcd")
    pub class_name: &'static str,
    /// A list of (css_variable_name, value_getter) pairs.
    /// These are applied as inline styles to the element.
    pub vars: Vec<(&'static str, CssVariableGetter)>,
    /// A list of (css_template, list of value getters) pairs for dynamic selector blocks.
    pub rules: Vec<(&'static str, Vec<CssVariableGetter>)>,
}

impl ApplyToDom for DynamicCss {
    fn apply(self, el: &web_sys::Element, target: ApplyTarget) {
        // 1. Apply class name (as normal string class)
        // This ensures the element gets the static CSS rules.
        self.class_name.apply(el, target);

        // 2. Apply dynamic variables (always as inline styles)
        for (name, getter) in self.vars {
            let el = el.clone();
            let name = name.to_string(); // 'static -> String for closure capture

            // Create an effect to keep the CSS variable in sync with the signal/expression
            silex_core::reactivity::Effect::new(move |_| {
                let value = getter();
                // Attempt to get style declaration from HtmlElement or SvgElement
                if let Some(style) = el
                    .dyn_ref::<web_sys::HtmlElement>()
                    .map(|e| e.style())
                    .or_else(|| el.dyn_ref::<web_sys::SvgElement>().map(|e| e.style()))
                {
                    // Set the CSS variable (e.g., --slx-1234-0: red)
                    let _ = style.set_property(&name, &value);
                }
            });
        }

        // 3. Apply isolated component dynamic rules
        if !self.rules.is_empty() {
            std::thread_local! {
                static INSTANCE_COUNTER: std::cell::Cell<usize> = const { std::cell::Cell::new(0) };
            }
            let instance_id = INSTANCE_COUNTER.with(|c| {
                let id = c.get();
                c.set(id + 1);
                id
            });
            let style_id = format!("{}-dyn-{}", self.class_name, instance_id);

            let manager = Rc::new(DynamicStyleManager::new(&style_id));
            let rules = self.rules;

            silex_core::reactivity::Effect::new(move |_| {
                let mut combined_css = String::new();
                for (template, getters) in &rules {
                    let mut result_rule = template.to_string();
                    for getter in getters {
                        let val = getter();
                        if let Some(pos) = result_rule.find("{}") {
                            result_rule.replace_range(pos..pos + 2, &val);
                        }
                    }
                    combined_css.push_str(&result_rule);
                    combined_css.push('\n');
                }
                manager.update(&combined_css);
            });
        }
    }
}

// Allow passing DynamicCss directly to .class() or .attr()
impl IntoStorable for DynamicCss {
    type Stored = Self;
    fn into_storable(self) -> Self::Stored {
        self
    }
}

/// Helper function to create a reactive string getter from any signal-like value.
/// Used by the css! macro to handle $(...) interpolation.
pub fn make_dynamic_val_for<P, S>(source: S) -> Rc<dyn Fn() -> String>
where
    S: IntoSignal,
    S::Value: Clone + Sized + types::ValidFor<P> + Display,
    S::Signal: Get + 'static,
    <S::Signal as With>::Value: Display,
{
    let signal = source.into_signal();
    Rc::new(move || format!("{}", signal.get()))
}
